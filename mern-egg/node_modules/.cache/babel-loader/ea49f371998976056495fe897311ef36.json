{"ast":null,"code":"/* eslint-disable max-depth, max-params, no-warning-comments */\nconst {\n  v4: uuid\n} = require('uuid');\n\nconst moment = require('moment-timezone');\n\nconst rrule = require('rrule').RRule;\n/** **************\n *  A tolerant, minimal icalendar parser\n *  (http://tools.ietf.org/html/rfc5545)\n *\n *  <peterbraden@peterbraden.co.uk>\n * ************* */\n// Unescape Text re RFC 4.3.11\n\n\nconst text = function (t = '') {\n  return t.replace(/\\\\,/g, ',').replace(/\\\\;/g, ';').replace(/\\\\[nN]/g, '\\n').replace(/\\\\\\\\/g, '\\\\');\n};\n\nconst parseValue = function (value) {\n  if (value === 'TRUE') {\n    return true;\n  }\n\n  if (value === 'FALSE') {\n    return false;\n  }\n\n  const number = Number(value);\n\n  if (!Number.isNaN(number)) {\n    return number;\n  }\n\n  return value;\n};\n\nconst parseParameters = function (p) {\n  const out = {};\n\n  for (const element of p) {\n    if (element.includes('=')) {\n      const segs = element.split('=');\n      out[segs[0]] = parseValue(segs.slice(1).join('='));\n    }\n  } // Sp is not defined in this scope, typo?\n  // original code from peterbraden\n  // return out || sp;\n\n\n  return out;\n};\n\nconst storeValueParameter = function (name) {\n  return function (value, curr) {\n    const current = curr[name];\n\n    if (Array.isArray(current)) {\n      current.push(value);\n      return curr;\n    }\n\n    if (typeof current === 'undefined') {\n      curr[name] = value;\n    } else {\n      curr[name] = [current, value];\n    }\n\n    return curr;\n  };\n};\n\nconst storeParameter = function (name) {\n  return function (value, parameters, curr) {\n    const data = parameters && parameters.length > 0 && !(parameters.length === 1 && parameters[0] === 'CHARSET=utf-8') ? {\n      params: parseParameters(parameters),\n      val: text(value)\n    } : text(value);\n    return storeValueParameter(name)(data, curr);\n  };\n};\n\nconst addTZ = function (dt, parameters) {\n  const p = parseParameters(parameters);\n\n  if (parameters && p && dt) {\n    dt.tz = p.TZID;\n\n    if (dt.tz !== undefined) {\n      // Remove surrouding quotes if found at the begining and at the end of the string\n      // (Occurs when parsing Microsoft Exchange events containing TZID with Windows standard format instead IANA)\n      dt.tz = dt.tz.replace(/^\"(.*)\"$/, '$1');\n    }\n  }\n\n  return dt;\n};\n\nlet zoneTable = null;\n\nfunction getIanaTZFromMS(msTZName) {\n  if (!zoneTable) {\n    const p = require('path');\n\n    zoneTable = require(p.join(__dirname, 'windowsZones.json'));\n  } // Get hash entry\n\n\n  const he = zoneTable[msTZName]; // If found return iana name, else null\n\n  return he ? he.iana[0] : null;\n}\n\nconst typeParameter = function (name) {\n  // Typename is not used in this function?\n  return function (value, parameters, curr) {\n    let returnValue = 'date-time';\n\n    if (parameters && parameters.includes('VALUE=DATE') && !parameters.includes('VALUE=DATE-TIME')) {\n      returnValue = 'date';\n    }\n\n    return storeValueParameter(name)(returnValue, curr);\n  };\n};\n\nconst dateParameter = function (name) {\n  return function (value, parameters, curr) {\n    let newDate = text(value); // Process 'VALUE=DATE' and EXDATE\n\n    if (parameters && parameters.includes('VALUE=DATE') && !parameters.includes('VALUE=DATE-TIME') || /^\\d{8}$/.test(value) === true) {\n      // Just Date\n      const comps = /^(\\d{4})(\\d{2})(\\d{2}).*$/.exec(value);\n\n      if (comps !== null) {\n        // No TZ info - assume same timezone as this computer\n        newDate = new Date(comps[1], Number.parseInt(comps[2], 10) - 1, comps[3]);\n        newDate = addTZ(newDate, parameters);\n        newDate.dateOnly = true; // Store as string - worst case scenario\n\n        return storeValueParameter(name)(newDate, curr);\n      }\n    } // Typical RFC date-time format\n\n\n    const comps = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(value);\n\n    if (comps !== null) {\n      if (comps[7] === 'Z') {\n        // GMT\n        newDate = new Date(Date.UTC(Number.parseInt(comps[1], 10), Number.parseInt(comps[2], 10) - 1, Number.parseInt(comps[3], 10), Number.parseInt(comps[4], 10), Number.parseInt(comps[5], 10), Number.parseInt(comps[6], 10))); // TODO add tz\n      } else if (parameters && parameters[0] && parameters[0].includes('TZID=') && parameters[0].split('=')[1]) {\n        // Get the timeozone from trhe parameters TZID value\n        let tz = parameters[0].split('=')[1];\n        let found = '';\n        let offset = ''; // Remove quotes if found\n\n        tz = tz.replace(/^\"(.*)\"$/, '$1'); // Watch out for windows timezones\n\n        if (tz && tz.includes(' ')) {\n          const tz1 = getIanaTZFromMS(tz);\n\n          if (tz1) {\n            tz = tz1; // We have a confirmed timezone, dont use offset, may confuse DST/STD time\n\n            offset = '';\n          }\n        } // Watch out for offset timezones\n        // If the conversion above didn't find any matching IANA tz\n        // And oiffset is still present\n\n\n        if (tz && tz.startsWith('(')) {\n          // Extract just the offset\n          const regex = /[+|-]\\d*:\\d*/;\n          offset = tz.match(regex);\n          tz = null;\n          found = offset;\n        } // Timezone not confirmed yet\n\n\n        if (found === '') {\n          // Lookup tz\n          found = moment.tz.names().find(zone => {\n            return zone === tz;\n          });\n        } // Timezone confirmed or forced to offset\n\n\n        newDate = found ? moment.tz(value, 'YYYYMMDDTHHmmss' + offset, tz).toDate() : new Date(Number.parseInt(comps[1], 10), Number.parseInt(comps[2], 10) - 1, Number.parseInt(comps[3], 10), Number.parseInt(comps[4], 10), Number.parseInt(comps[5], 10), Number.parseInt(comps[6], 10));\n      } else {\n        newDate = new Date(Number.parseInt(comps[1], 10), Number.parseInt(comps[2], 10) - 1, Number.parseInt(comps[3], 10), Number.parseInt(comps[4], 10), Number.parseInt(comps[5], 10), Number.parseInt(comps[6], 10));\n      }\n\n      newDate = addTZ(newDate, parameters);\n    } // Store as string - worst case scenario\n\n\n    return storeValueParameter(name)(newDate, curr);\n  };\n};\n\nconst geoParameter = function (name) {\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n    const parts = value.split(';');\n    curr[name] = {\n      lat: Number(parts[0]),\n      lon: Number(parts[1])\n    };\n    return curr;\n  };\n};\n\nconst categoriesParameter = function (name) {\n  const separatorPattern = /\\s*,\\s*/g;\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n\n    if (curr[name] === undefined) {\n      curr[name] = value ? value.split(separatorPattern) : [];\n    } else if (value) {\n      curr[name] = curr[name].concat(value.split(separatorPattern));\n    }\n\n    return curr;\n  };\n}; // EXDATE is an entry that represents exceptions to a recurrence rule (ex: \"repeat every day except on 7/4\").\n// The EXDATE entry itself can also contain a comma-separated list, so we make sure to parse each date out separately.\n// There can also be more than one EXDATE entries in a calendar record.\n// Since there can be multiple dates, we create an array of them.  The index into the array is the ISO string of the date itself, for ease of use.\n// i.e. You can check if ((curr.exdate != undefined) && (curr.exdate[date iso string] != undefined)) to see if a date is an exception.\n// NOTE: This specifically uses date only, and not time.  This is to avoid a few problems:\n//    1. The ISO string with time wouldn't work for \"floating dates\" (dates without timezones).\n//       ex: \"20171225T060000\" - this is supposed to mean 6 AM in whatever timezone you're currently in\n//    2. Daylight savings time potentially affects the time you would need to look up\n//    3. Some EXDATE entries in the wild seem to have times different from the recurrence rule, but are still excluded by calendar programs.  Not sure how or why.\n//       These would fail any sort of sane time lookup, because the time literally doesn't match the event.  So we'll ignore time and just use date.\n//       ex: DTSTART:20170814T140000Z\n//             RRULE:FREQ=WEEKLY;WKST=SU;INTERVAL=2;BYDAY=MO,TU\n//             EXDATE:20171219T060000\n//       Even though \"T060000\" doesn't match or overlap \"T1400000Z\", it's still supposed to be excluded?  Odd. :(\n// TODO: See if this causes any problems with events that recur multiple times a day.\n\n\nconst exdateParameter = function (name) {\n  return function (value, parameters, curr) {\n    const separatorPattern = /\\s*,\\s*/g;\n    curr[name] = curr[name] || [];\n    const dates = value ? value.split(separatorPattern) : [];\n    dates.forEach(entry => {\n      const exdate = [];\n      dateParameter(name)(entry, parameters, exdate);\n\n      if (exdate[name]) {\n        if (typeof exdate[name].toISOString === 'function') {\n          curr[name][exdate[name].toISOString().slice(0, 10)] = exdate[name];\n        } else {\n          throw new TypeError('No toISOString function in exdate[name]', exdate[name]);\n        }\n      }\n    });\n    return curr;\n  };\n}; // RECURRENCE-ID is the ID of a specific recurrence within a recurrence rule.\n// TODO:  It's also possible for it to have a range, like \"THISANDPRIOR\", \"THISANDFUTURE\".  This isn't currently handled.\n\n\nconst recurrenceParameter = function (name) {\n  return dateParameter(name);\n};\n\nconst addFBType = function (fb, parameters) {\n  const p = parseParameters(parameters);\n\n  if (parameters && p) {\n    fb.type = p.FBTYPE || 'BUSY';\n  }\n\n  return fb;\n};\n\nconst freebusyParameter = function (name) {\n  return function (value, parameters, curr) {\n    const fb = addFBType({}, parameters);\n    curr[name] = curr[name] || [];\n    curr[name].push(fb);\n    storeParameter(value, parameters, fb);\n    const parts = value.split('/');\n    ['start', 'end'].forEach((name, index) => {\n      dateParameter(name)(parts[index], parameters, fb);\n    });\n    return curr;\n  };\n};\n\nmodule.exports = {\n  objectHandlers: {\n    BEGIN(component, parameters, curr, stack) {\n      stack.push(curr);\n      return {\n        type: component,\n        params: parameters\n      };\n    },\n\n    END(value, parameters, curr, stack) {\n      // Original end function\n      const originalEnd = function (component, parameters_, curr, stack) {\n        // Prevents the need to search the root of the tree for the VCALENDAR object\n        if (component === 'VCALENDAR') {\n          // Scan all high level object in curr and drop all strings\n          let key;\n          let object;\n\n          for (key in curr) {\n            if (!{}.hasOwnProperty.call(curr, key)) {\n              continue;\n            }\n\n            object = curr[key];\n\n            if (typeof object === 'string') {\n              delete curr[key];\n            }\n          }\n\n          return curr;\n        }\n\n        const par = stack.pop();\n\n        if (curr.uid) {\n          // If this is the first time we run into this UID, just save it.\n          if (par[curr.uid] === undefined) {\n            par[curr.uid] = curr;\n          } else if (curr.recurrenceid === undefined) {\n            // If we have multiple ical entries with the same UID, it's either going to be a\n            // modification to a recurrence (RECURRENCE-ID), and/or a significant modification\n            // to the entry (SEQUENCE).\n            // TODO: Look into proper sequence logic.\n            // If we have the same UID as an existing record, and it *isn't* a specific recurrence ID,\n            // not quite sure what the correct behaviour should be.  For now, just take the new information\n            // and merge it with the old record by overwriting only the fields that appear in the new record.\n            let key;\n\n            for (key in curr) {\n              if (key !== null) {\n                par[curr.uid][key] = curr[key];\n              }\n            }\n          } // If we have recurrence-id entries, list them as an array of recurrences keyed off of recurrence-id.\n          // To use - as you're running through the dates of an rrule, you can try looking it up in the recurrences\n          // array.  If it exists, then use the data from the calendar object in the recurrence instead of the parent\n          // for that day.\n          // NOTE:  Sometimes the RECURRENCE-ID record will show up *before* the record with the RRULE entry.  In that\n          // case, what happens is that the RECURRENCE-ID record ends up becoming both the parent record and an entry\n          // in the recurrences array, and then when we process the RRULE entry later it overwrites the appropriate\n          // fields in the parent record.\n\n\n          if (typeof curr.recurrenceid !== 'undefined') {\n            // TODO:  Is there ever a case where we have to worry about overwriting an existing entry here?\n            // Create a copy of the current object to save in our recurrences array.  (We *could* just do par = curr,\n            // except for the case that we get the RECURRENCE-ID record before the RRULE record.  In that case, we\n            // would end up with a shared reference that would cause us to overwrite *both* records at the point\n            // that we try and fix up the parent record.)\n            const recurrenceObject = {};\n            let key;\n\n            for (key in curr) {\n              if (key !== null) {\n                recurrenceObject[key] = curr[key];\n              }\n            }\n\n            if (typeof recurrenceObject.recurrences !== 'undefined') {\n              delete recurrenceObject.recurrences;\n            } // If we don't have an array to store recurrences in yet, create it.\n\n\n            if (par[curr.uid].recurrences === undefined) {\n              par[curr.uid].recurrences = {};\n            } // Save off our cloned recurrence object into the array, keyed by date but not time.\n            // We key by date only to avoid timezone and \"floating time\" problems (where the time isn't associated with a timezone).\n            // TODO: See if this causes a problem with events that have multiple recurrences per day.\n\n\n            if (typeof curr.recurrenceid.toISOString === 'function') {\n              par[curr.uid].recurrences[curr.recurrenceid.toISOString().slice(0, 10)] = recurrenceObject;\n            } else {\n              throw new TypeError('No toISOString function in curr.recurrenceid', curr.recurrenceid);\n            }\n          } // One more specific fix - in the case that an RRULE entry shows up after a RECURRENCE-ID entry,\n          // let's make sure to clear the recurrenceid off the parent field.\n\n\n          if (typeof par[curr.uid].rrule !== 'undefined' && typeof par[curr.uid].recurrenceid !== 'undefined') {\n            delete par[curr.uid].recurrenceid;\n          }\n        } else {\n          par[uuid()] = curr;\n        }\n\n        return par;\n      }; // Recurrence rules are only valid for VEVENT, VTODO, and VJOURNAL.\n      // More specifically, we need to filter the VCALENDAR type because we might end up with a defined rrule\n      // due to the subtypes.\n\n\n      if ((value === 'VEVENT' || value === 'VTODO' || value === 'VJOURNAL') && curr.rrule) {\n        let rule = curr.rrule.replace('RRULE:', ''); // Make sure the rrule starts with FREQ=\n\n        rule = rule.slice(rule.lastIndexOf('FREQ=')); // If no rule start date\n\n        if (rule.includes('DTSTART') === false) {\n          // Get date/time into a specific format for comapare\n          let x = moment(curr.start).format('MMMM/Do/YYYY, h:mm:ss a'); // If the local time value is midnight\n          // This a whole day event\n\n          if (x.slice(-11) === '12:00:00 am') {\n            // Get the timezone offset\n            // The internal date is stored in UTC format\n            const offset = curr.start.getTimezoneOffset(); // Only east of gmt is a problem\n\n            if (offset < 0) {\n              // Calculate the new startdate with the offset applied, bypass RRULE/Luxon confusion\n              // Make the internally stored DATE the actual date (not UTC offseted)\n              // Luxon expects local time, not utc, so gets start date wrong if not adjusted\n              curr.start = new Date(curr.start.getTime() + Math.abs(offset) * 60000);\n            } else {\n              // Get rid of any time (shouldn't be any, but be sure)\n              x = moment(curr.start).format('MMMM/Do/YYYY');\n              const comps = /^(\\d{2})\\/(\\d{2})\\/(\\d{4})/.exec(x);\n\n              if (comps) {\n                curr.start = new Date(comps[3], comps[1] - 1, comps[2]);\n              }\n            }\n          } // If the date has an toISOString function\n\n\n          if (curr.start && typeof curr.start.toISOString === 'function') {\n            try {\n              rule += `;DTSTART=${curr.start.toISOString().replace(/[-:]/g, '')}`;\n              rule = rule.replace(/\\.\\d{3}/, '');\n            } catch (error) {\n              throw new Error('ERROR when trying to convert to ISOString', error);\n            }\n          } else {\n            throw new Error('No toISOString function in curr.start', curr.start);\n          }\n        } // Make sure to catch error from rrule.fromString()\n\n\n        try {\n          curr.rrule = rrule.fromString(rule);\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      return originalEnd.call(this, value, parameters, curr, stack);\n    },\n\n    SUMMARY: storeParameter('summary'),\n    DESCRIPTION: storeParameter('description'),\n    URL: storeParameter('url'),\n    UID: storeParameter('uid'),\n    LOCATION: storeParameter('location'),\n\n    DTSTART(value, parameters, curr) {\n      curr = dateParameter('start')(value, parameters, curr);\n      return typeParameter('datetype')(value, parameters, curr);\n    },\n\n    DTEND: dateParameter('end'),\n    EXDATE: exdateParameter('exdate'),\n    ' CLASS': storeParameter('class'),\n    // Should there be a space in this property?\n    TRANSP: storeParameter('transparency'),\n    GEO: geoParameter('geo'),\n    'PERCENT-COMPLETE': storeParameter('completion'),\n    COMPLETED: dateParameter('completed'),\n    CATEGORIES: categoriesParameter('categories'),\n    FREEBUSY: freebusyParameter('freebusy'),\n    DTSTAMP: dateParameter('dtstamp'),\n    CREATED: dateParameter('created'),\n    'LAST-MODIFIED': dateParameter('lastmodified'),\n    'RECURRENCE-ID': recurrenceParameter('recurrenceid'),\n\n    RRULE(value, parameters, curr, stack, line) {\n      curr.rrule = line;\n      return curr;\n    }\n\n  },\n\n  handleObject(name, value, parameters, ctx, stack, line) {\n    const self = this;\n\n    if (self.objectHandlers[name]) {\n      return self.objectHandlers[name](value, parameters, ctx, stack, line);\n    } // Handling custom properties\n\n\n    if (name.match(/X-[\\w-]+/) && stack.length > 0) {\n      // Trimming the leading and perform storeParam\n      name = name.slice(2);\n      return storeParameter(name)(value, parameters, ctx, stack, line);\n    }\n\n    return storeParameter(name.toLowerCase())(value, parameters, ctx);\n  },\n\n  parseLines(lines, limit, ctx, stack, lastIndex, cb) {\n    const self = this;\n\n    if (!cb && typeof ctx === 'function') {\n      cb = ctx;\n      ctx = undefined;\n    }\n\n    ctx = ctx || {};\n    stack = stack || [];\n    let limitCounter = 0;\n    let i = lastIndex || 0;\n\n    for (let ii = lines.length; i < ii; i++) {\n      let l = lines[i]; // Unfold : RFC#3.1\n\n      while (lines[i + 1] && /[ \\t]/.test(lines[i + 1][0])) {\n        l += lines[i + 1].slice(1);\n        i++;\n      } // Remove any double quotes in any tzid statement// except around (utc+hh:mm\n\n\n      if (l.indexOf('TZID=') && !l.includes('\"(')) {\n        l = l.replace(/\"/g, '');\n      }\n\n      const exp = /([^\":;]+)((?:;[^\":;]+=(?:(?:\"[^\"]*\")|[^\":;]+))*):(.*)/;\n      let kv = l.match(exp);\n\n      if (kv === null) {\n        // Invalid line - must have k&v\n        continue;\n      }\n\n      kv = kv.slice(1);\n      const value = kv[kv.length - 1];\n      const name = kv[0];\n      const parameters = kv[1] ? kv[1].split(';').slice(1) : [];\n      ctx = self.handleObject(name, value, parameters, ctx, stack, l) || {};\n\n      if (++limitCounter > limit) {\n        break;\n      }\n    }\n\n    if (i >= lines.length) {\n      // Type and params are added to the list of items, get rid of them.\n      delete ctx.type;\n      delete ctx.params;\n    }\n\n    if (cb) {\n      if (i < lines.length) {\n        setImmediate(() => {\n          self.parseLines(lines, limit, ctx, stack, i + 1, cb);\n        });\n      } else {\n        setImmediate(() => {\n          cb(null, ctx);\n        });\n      }\n    } else {\n      return ctx;\n    }\n  },\n\n  getLineBreakChar(string) {\n    const indexOfLF = string.indexOf('\\n', 1); // No need to check first-character\n\n    if (indexOfLF === -1) {\n      if (string.includes('\\r')) {\n        return '\\r';\n      }\n\n      return '\\n';\n    }\n\n    if (string[indexOfLF - 1] === '\\r') {\n      return '\\r?\\n';\n    }\n\n    return '\\n';\n  },\n\n  parseICS(string, cb) {\n    const self = this;\n    const lineEndType = self.getLineBreakChar(string);\n    const lines = string.split(lineEndType === '\\n' ? /\\n/ : /\\r?\\n/);\n    let ctx;\n\n    if (cb) {\n      // Asynchronous execution\n      self.parseLines(lines, 2000, cb);\n    } else {\n      // Synchronous execution\n      ctx = self.parseLines(lines, lines.length);\n      return ctx;\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/tyleryoun/Desktop/PROJECT/mern-egg/node_modules/node-ical/ical.js"],"names":["v4","uuid","require","moment","rrule","RRule","text","t","replace","parseValue","value","number","Number","isNaN","parseParameters","p","out","element","includes","segs","split","slice","join","storeValueParameter","name","curr","current","Array","isArray","push","storeParameter","parameters","data","length","params","val","addTZ","dt","tz","TZID","undefined","zoneTable","getIanaTZFromMS","msTZName","__dirname","he","iana","typeParameter","returnValue","dateParameter","newDate","test","comps","exec","Date","parseInt","dateOnly","UTC","found","offset","tz1","startsWith","regex","match","names","find","zone","toDate","geoParameter","parts","lat","lon","categoriesParameter","separatorPattern","concat","exdateParameter","dates","forEach","entry","exdate","toISOString","TypeError","recurrenceParameter","addFBType","fb","type","FBTYPE","freebusyParameter","index","module","exports","objectHandlers","BEGIN","component","stack","END","originalEnd","parameters_","key","object","hasOwnProperty","call","par","pop","uid","recurrenceid","recurrenceObject","recurrences","rule","lastIndexOf","x","start","format","getTimezoneOffset","getTime","Math","abs","error","Error","fromString","SUMMARY","DESCRIPTION","URL","UID","LOCATION","DTSTART","DTEND","EXDATE","TRANSP","GEO","COMPLETED","CATEGORIES","FREEBUSY","DTSTAMP","CREATED","RRULE","line","handleObject","ctx","self","toLowerCase","parseLines","lines","limit","lastIndex","cb","limitCounter","i","ii","l","indexOf","exp","kv","setImmediate","getLineBreakChar","string","indexOfLF","parseICS","lineEndType"],"mappings":"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","sourcesContent":["/* eslint-disable max-depth, max-params, no-warning-comments */\n\nconst {v4: uuid} = require('uuid');\nconst moment = require('moment-timezone');\nconst rrule = require('rrule').RRule;\n\n/** **************\n *  A tolerant, minimal icalendar parser\n *  (http://tools.ietf.org/html/rfc5545)\n *\n *  <peterbraden@peterbraden.co.uk>\n * ************* */\n\n// Unescape Text re RFC 4.3.11\nconst text = function (t = '') {\n  return t\n    .replace(/\\\\,/g, ',')\n    .replace(/\\\\;/g, ';')\n    .replace(/\\\\[nN]/g, '\\n')\n    .replace(/\\\\\\\\/g, '\\\\');\n};\n\nconst parseValue = function (value) {\n  if (value === 'TRUE') {\n    return true;\n  }\n\n  if (value === 'FALSE') {\n    return false;\n  }\n\n  const number = Number(value);\n  if (!Number.isNaN(number)) {\n    return number;\n  }\n\n  return value;\n};\n\nconst parseParameters = function (p) {\n  const out = {};\n  for (const element of p) {\n    if (element.includes('=')) {\n      const segs = element.split('=');\n\n      out[segs[0]] = parseValue(segs.slice(1).join('='));\n    }\n  }\n\n  // Sp is not defined in this scope, typo?\n  // original code from peterbraden\n  // return out || sp;\n  return out;\n};\n\nconst storeValueParameter = function (name) {\n  return function (value, curr) {\n    const current = curr[name];\n\n    if (Array.isArray(current)) {\n      current.push(value);\n      return curr;\n    }\n\n    if (typeof current === 'undefined') {\n      curr[name] = value;\n    } else {\n      curr[name] = [current, value];\n    }\n\n    return curr;\n  };\n};\n\nconst storeParameter = function (name) {\n  return function (value, parameters, curr) {\n    const data = parameters && parameters.length > 0 && !(parameters.length === 1 && parameters[0] === 'CHARSET=utf-8') ? {params: parseParameters(parameters), val: text(value)} : text(value);\n\n    return storeValueParameter(name)(data, curr);\n  };\n};\n\nconst addTZ = function (dt, parameters) {\n  const p = parseParameters(parameters);\n\n  if (parameters && p && dt) {\n    dt.tz = p.TZID;\n    if (dt.tz !== undefined) {\n      // Remove surrouding quotes if found at the begining and at the end of the string\n      // (Occurs when parsing Microsoft Exchange events containing TZID with Windows standard format instead IANA)\n      dt.tz = dt.tz.replace(/^\"(.*)\"$/, '$1');\n    }\n  }\n\n  return dt;\n};\n\nlet zoneTable = null;\nfunction getIanaTZFromMS(msTZName) {\n  if (!zoneTable) {\n    const p = require('path');\n    zoneTable = require(p.join(__dirname, 'windowsZones.json'));\n  }\n\n  // Get hash entry\n  const he = zoneTable[msTZName];\n  // If found return iana name, else null\n  return he ? he.iana[0] : null;\n}\n\nconst typeParameter = function (name) {\n  // Typename is not used in this function?\n  return function (value, parameters, curr) {\n    let returnValue = 'date-time';\n    if (parameters && parameters.includes('VALUE=DATE') && !parameters.includes('VALUE=DATE-TIME')) {\n      returnValue = 'date';\n    }\n\n    return storeValueParameter(name)(returnValue, curr);\n  };\n};\n\nconst dateParameter = function (name) {\n  return function (value, parameters, curr) {\n    let newDate = text(value);\n\n    // Process 'VALUE=DATE' and EXDATE\n    if ((parameters && parameters.includes('VALUE=DATE') && !parameters.includes('VALUE=DATE-TIME')) || /^\\d{8}$/.test(value) === true) {\n      // Just Date\n\n      const comps = /^(\\d{4})(\\d{2})(\\d{2}).*$/.exec(value);\n      if (comps !== null) {\n        // No TZ info - assume same timezone as this computer\n        newDate = new Date(comps[1], Number.parseInt(comps[2], 10) - 1, comps[3]);\n\n        newDate = addTZ(newDate, parameters);\n        newDate.dateOnly = true;\n\n        // Store as string - worst case scenario\n        return storeValueParameter(name)(newDate, curr);\n      }\n    }\n\n    // Typical RFC date-time format\n    const comps = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(value);\n    if (comps !== null) {\n      if (comps[7] === 'Z') {\n        // GMT\n        newDate = new Date(\n          Date.UTC(\n            Number.parseInt(comps[1], 10),\n            Number.parseInt(comps[2], 10) - 1,\n            Number.parseInt(comps[3], 10),\n            Number.parseInt(comps[4], 10),\n            Number.parseInt(comps[5], 10),\n            Number.parseInt(comps[6], 10)\n          )\n        );\n        // TODO add tz\n      } else if (parameters && parameters[0] && parameters[0].includes('TZID=') && parameters[0].split('=')[1]) {\n        // Get the timeozone from trhe parameters TZID value\n        let tz = parameters[0].split('=')[1];\n        let found = '';\n        let offset = '';\n\n        // Remove quotes if found\n        tz = tz.replace(/^\"(.*)\"$/, '$1');\n\n        // Watch out for windows timezones\n        if (tz && tz.includes(' ')) {\n          const tz1 = getIanaTZFromMS(tz);\n          if (tz1) {\n            tz = tz1;\n            // We have a confirmed timezone, dont use offset, may confuse DST/STD time\n            offset = '';\n          }\n        }\n\n        // Watch out for offset timezones\n        // If the conversion above didn't find any matching IANA tz\n        // And oiffset is still present\n        if (tz && tz.startsWith('(')) {\n          // Extract just the offset\n          const regex = /[+|-]\\d*:\\d*/;\n          offset = tz.match(regex);\n          tz = null;\n          found = offset;\n        }\n\n        // Timezone not confirmed yet\n        if (found === '') {\n          // Lookup tz\n          found = moment.tz.names().find(zone => {\n            return zone === tz;\n          });\n        }\n\n        // Timezone confirmed or forced to offset\n        newDate = found ? moment.tz(value, 'YYYYMMDDTHHmmss' + offset, tz).toDate() : new Date(\n          Number.parseInt(comps[1], 10),\n          Number.parseInt(comps[2], 10) - 1,\n          Number.parseInt(comps[3], 10),\n          Number.parseInt(comps[4], 10),\n          Number.parseInt(comps[5], 10),\n          Number.parseInt(comps[6], 10)\n        );\n      } else {\n        newDate = new Date(\n          Number.parseInt(comps[1], 10),\n          Number.parseInt(comps[2], 10) - 1,\n          Number.parseInt(comps[3], 10),\n          Number.parseInt(comps[4], 10),\n          Number.parseInt(comps[5], 10),\n          Number.parseInt(comps[6], 10)\n        );\n      }\n\n      newDate = addTZ(newDate, parameters);\n    }\n\n    // Store as string - worst case scenario\n    return storeValueParameter(name)(newDate, curr);\n  };\n};\n\nconst geoParameter = function (name) {\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n    const parts = value.split(';');\n    curr[name] = {lat: Number(parts[0]), lon: Number(parts[1])};\n    return curr;\n  };\n};\n\nconst categoriesParameter = function (name) {\n  const separatorPattern = /\\s*,\\s*/g;\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n    if (curr[name] === undefined) {\n      curr[name] = value ? value.split(separatorPattern) : [];\n    } else if (value) {\n      curr[name] = curr[name].concat(value.split(separatorPattern));\n    }\n\n    return curr;\n  };\n};\n\n// EXDATE is an entry that represents exceptions to a recurrence rule (ex: \"repeat every day except on 7/4\").\n// The EXDATE entry itself can also contain a comma-separated list, so we make sure to parse each date out separately.\n// There can also be more than one EXDATE entries in a calendar record.\n// Since there can be multiple dates, we create an array of them.  The index into the array is the ISO string of the date itself, for ease of use.\n// i.e. You can check if ((curr.exdate != undefined) && (curr.exdate[date iso string] != undefined)) to see if a date is an exception.\n// NOTE: This specifically uses date only, and not time.  This is to avoid a few problems:\n//    1. The ISO string with time wouldn't work for \"floating dates\" (dates without timezones).\n//       ex: \"20171225T060000\" - this is supposed to mean 6 AM in whatever timezone you're currently in\n//    2. Daylight savings time potentially affects the time you would need to look up\n//    3. Some EXDATE entries in the wild seem to have times different from the recurrence rule, but are still excluded by calendar programs.  Not sure how or why.\n//       These would fail any sort of sane time lookup, because the time literally doesn't match the event.  So we'll ignore time and just use date.\n//       ex: DTSTART:20170814T140000Z\n//             RRULE:FREQ=WEEKLY;WKST=SU;INTERVAL=2;BYDAY=MO,TU\n//             EXDATE:20171219T060000\n//       Even though \"T060000\" doesn't match or overlap \"T1400000Z\", it's still supposed to be excluded?  Odd. :(\n// TODO: See if this causes any problems with events that recur multiple times a day.\nconst exdateParameter = function (name) {\n  return function (value, parameters, curr) {\n    const separatorPattern = /\\s*,\\s*/g;\n    curr[name] = curr[name] || [];\n    const dates = value ? value.split(separatorPattern) : [];\n    dates.forEach(entry => {\n      const exdate = [];\n      dateParameter(name)(entry, parameters, exdate);\n\n      if (exdate[name]) {\n        if (typeof exdate[name].toISOString === 'function') {\n          curr[name][exdate[name].toISOString().slice(0, 10)] = exdate[name];\n        } else {\n          throw new TypeError('No toISOString function in exdate[name]', exdate[name]);\n        }\n      }\n    });\n    return curr;\n  };\n};\n\n// RECURRENCE-ID is the ID of a specific recurrence within a recurrence rule.\n// TODO:  It's also possible for it to have a range, like \"THISANDPRIOR\", \"THISANDFUTURE\".  This isn't currently handled.\nconst recurrenceParameter = function (name) {\n  return dateParameter(name);\n};\n\nconst addFBType = function (fb, parameters) {\n  const p = parseParameters(parameters);\n\n  if (parameters && p) {\n    fb.type = p.FBTYPE || 'BUSY';\n  }\n\n  return fb;\n};\n\nconst freebusyParameter = function (name) {\n  return function (value, parameters, curr) {\n    const fb = addFBType({}, parameters);\n    curr[name] = curr[name] || [];\n    curr[name].push(fb);\n\n    storeParameter(value, parameters, fb);\n\n    const parts = value.split('/');\n\n    ['start', 'end'].forEach((name, index) => {\n      dateParameter(name)(parts[index], parameters, fb);\n    });\n\n    return curr;\n  };\n};\n\nmodule.exports = {\n  objectHandlers: {\n    BEGIN(component, parameters, curr, stack) {\n      stack.push(curr);\n\n      return {type: component, params: parameters};\n    },\n    END(value, parameters, curr, stack) {\n      // Original end function\n      const originalEnd = function (component, parameters_, curr, stack) {\n        // Prevents the need to search the root of the tree for the VCALENDAR object\n        if (component === 'VCALENDAR') {\n          // Scan all high level object in curr and drop all strings\n          let key;\n          let object;\n\n          for (key in curr) {\n            if (!{}.hasOwnProperty.call(curr, key)) {\n              continue;\n            }\n\n            object = curr[key];\n            if (typeof object === 'string') {\n              delete curr[key];\n            }\n          }\n\n          return curr;\n        }\n\n        const par = stack.pop();\n\n        if (curr.uid) {\n          // If this is the first time we run into this UID, just save it.\n          if (par[curr.uid] === undefined) {\n            par[curr.uid] = curr;\n          } else if (curr.recurrenceid === undefined) {\n            // If we have multiple ical entries with the same UID, it's either going to be a\n            // modification to a recurrence (RECURRENCE-ID), and/or a significant modification\n            // to the entry (SEQUENCE).\n\n            // TODO: Look into proper sequence logic.\n\n            // If we have the same UID as an existing record, and it *isn't* a specific recurrence ID,\n            // not quite sure what the correct behaviour should be.  For now, just take the new information\n            // and merge it with the old record by overwriting only the fields that appear in the new record.\n            let key;\n            for (key in curr) {\n              if (key !== null) {\n                par[curr.uid][key] = curr[key];\n              }\n            }\n          }\n\n          // If we have recurrence-id entries, list them as an array of recurrences keyed off of recurrence-id.\n          // To use - as you're running through the dates of an rrule, you can try looking it up in the recurrences\n          // array.  If it exists, then use the data from the calendar object in the recurrence instead of the parent\n          // for that day.\n\n          // NOTE:  Sometimes the RECURRENCE-ID record will show up *before* the record with the RRULE entry.  In that\n          // case, what happens is that the RECURRENCE-ID record ends up becoming both the parent record and an entry\n          // in the recurrences array, and then when we process the RRULE entry later it overwrites the appropriate\n          // fields in the parent record.\n\n          if (typeof curr.recurrenceid !== 'undefined') {\n            // TODO:  Is there ever a case where we have to worry about overwriting an existing entry here?\n\n            // Create a copy of the current object to save in our recurrences array.  (We *could* just do par = curr,\n            // except for the case that we get the RECURRENCE-ID record before the RRULE record.  In that case, we\n            // would end up with a shared reference that would cause us to overwrite *both* records at the point\n            // that we try and fix up the parent record.)\n            const recurrenceObject = {};\n            let key;\n            for (key in curr) {\n              if (key !== null) {\n                recurrenceObject[key] = curr[key];\n              }\n            }\n\n            if (typeof recurrenceObject.recurrences !== 'undefined') {\n              delete recurrenceObject.recurrences;\n            }\n\n            // If we don't have an array to store recurrences in yet, create it.\n            if (par[curr.uid].recurrences === undefined) {\n              par[curr.uid].recurrences = {};\n            }\n\n            // Save off our cloned recurrence object into the array, keyed by date but not time.\n            // We key by date only to avoid timezone and \"floating time\" problems (where the time isn't associated with a timezone).\n            // TODO: See if this causes a problem with events that have multiple recurrences per day.\n            if (typeof curr.recurrenceid.toISOString === 'function') {\n              par[curr.uid].recurrences[curr.recurrenceid.toISOString().slice(0, 10)] = recurrenceObject;\n            } else {\n              throw new TypeError('No toISOString function in curr.recurrenceid', curr.recurrenceid);\n            }\n          }\n\n          // One more specific fix - in the case that an RRULE entry shows up after a RECURRENCE-ID entry,\n          // let's make sure to clear the recurrenceid off the parent field.\n          if (typeof par[curr.uid].rrule !== 'undefined' && typeof par[curr.uid].recurrenceid !== 'undefined') {\n            delete par[curr.uid].recurrenceid;\n          }\n        } else {\n          par[uuid()] = curr;\n        }\n\n        return par;\n      };\n\n      // Recurrence rules are only valid for VEVENT, VTODO, and VJOURNAL.\n      // More specifically, we need to filter the VCALENDAR type because we might end up with a defined rrule\n      // due to the subtypes.\n\n      if ((value === 'VEVENT' || value === 'VTODO' || value === 'VJOURNAL') && curr.rrule) {\n        let rule = curr.rrule.replace('RRULE:', '');\n        // Make sure the rrule starts with FREQ=\n        rule = rule.slice(rule.lastIndexOf('FREQ='));\n        // If no rule start date\n        if (rule.includes('DTSTART') === false) {\n          // Get date/time into a specific format for comapare\n          let x = moment(curr.start).format('MMMM/Do/YYYY, h:mm:ss a');\n          // If the local time value is midnight\n          // This a whole day event\n          if (x.slice(-11) === '12:00:00 am') {\n            // Get the timezone offset\n            // The internal date is stored in UTC format\n            const offset = curr.start.getTimezoneOffset();\n            // Only east of gmt is a problem\n            if (offset < 0) {\n              // Calculate the new startdate with the offset applied, bypass RRULE/Luxon confusion\n              // Make the internally stored DATE the actual date (not UTC offseted)\n              // Luxon expects local time, not utc, so gets start date wrong if not adjusted\n              curr.start = new Date(curr.start.getTime() + (Math.abs(offset) * 60000));\n            } else {\n              // Get rid of any time (shouldn't be any, but be sure)\n              x = moment(curr.start).format('MMMM/Do/YYYY');\n              const comps = /^(\\d{2})\\/(\\d{2})\\/(\\d{4})/.exec(x);\n              if (comps) {\n                curr.start = new Date(comps[3], comps[1] - 1, comps[2]);\n              }\n            }\n          }\n\n          // If the date has an toISOString function\n          if (curr.start && typeof curr.start.toISOString === 'function') {\n            try {\n              rule += `;DTSTART=${curr.start.toISOString().replace(/[-:]/g, '')}`;\n              rule = rule.replace(/\\.\\d{3}/, '');\n            } catch (error) {\n              throw new Error('ERROR when trying to convert to ISOString', error);\n            }\n          } else {\n            throw new Error('No toISOString function in curr.start', curr.start);\n          }\n        }\n\n        // Make sure to catch error from rrule.fromString()\n        try {\n          curr.rrule = rrule.fromString(rule);\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      return originalEnd.call(this, value, parameters, curr, stack);\n    },\n    SUMMARY: storeParameter('summary'),\n    DESCRIPTION: storeParameter('description'),\n    URL: storeParameter('url'),\n    UID: storeParameter('uid'),\n    LOCATION: storeParameter('location'),\n    DTSTART(value, parameters, curr) {\n      curr = dateParameter('start')(value, parameters, curr);\n      return typeParameter('datetype')(value, parameters, curr);\n    },\n    DTEND: dateParameter('end'),\n    EXDATE: exdateParameter('exdate'),\n    ' CLASS': storeParameter('class'), // Should there be a space in this property?\n    TRANSP: storeParameter('transparency'),\n    GEO: geoParameter('geo'),\n    'PERCENT-COMPLETE': storeParameter('completion'),\n    COMPLETED: dateParameter('completed'),\n    CATEGORIES: categoriesParameter('categories'),\n    FREEBUSY: freebusyParameter('freebusy'),\n    DTSTAMP: dateParameter('dtstamp'),\n    CREATED: dateParameter('created'),\n    'LAST-MODIFIED': dateParameter('lastmodified'),\n    'RECURRENCE-ID': recurrenceParameter('recurrenceid'),\n    RRULE(value, parameters, curr, stack, line) {\n      curr.rrule = line;\n      return curr;\n    }\n  },\n\n  handleObject(name, value, parameters, ctx, stack, line) {\n    const self = this;\n\n    if (self.objectHandlers[name]) {\n      return self.objectHandlers[name](value, parameters, ctx, stack, line);\n    }\n\n    // Handling custom properties\n    if (name.match(/X-[\\w-]+/) && stack.length > 0) {\n      // Trimming the leading and perform storeParam\n      name = name.slice(2);\n      return storeParameter(name)(value, parameters, ctx, stack, line);\n    }\n\n    return storeParameter(name.toLowerCase())(value, parameters, ctx);\n  },\n\n  parseLines(lines, limit, ctx, stack, lastIndex, cb) {\n    const self = this;\n\n    if (!cb && typeof ctx === 'function') {\n      cb = ctx;\n      ctx = undefined;\n    }\n\n    ctx = ctx || {};\n    stack = stack || [];\n\n    let limitCounter = 0;\n\n    let i = lastIndex || 0;\n    for (let ii = lines.length; i < ii; i++) {\n      let l = lines[i];\n      // Unfold : RFC#3.1\n      while (lines[i + 1] && /[ \\t]/.test(lines[i + 1][0])) {\n        l += lines[i + 1].slice(1);\n        i++;\n      }\n\n      // Remove any double quotes in any tzid statement// except around (utc+hh:mm\n      if (l.indexOf('TZID=') && !l.includes('\"(')) {\n        l = l.replace(/\"/g, '');\n      }\n\n      const exp = /([^\":;]+)((?:;[^\":;]+=(?:(?:\"[^\"]*\")|[^\":;]+))*):(.*)/;\n      let kv = l.match(exp);\n\n      if (kv === null) {\n        // Invalid line - must have k&v\n        continue;\n      }\n\n      kv = kv.slice(1);\n\n      const value = kv[kv.length - 1];\n      const name = kv[0];\n      const parameters = kv[1] ? kv[1].split(';').slice(1) : [];\n\n      ctx = self.handleObject(name, value, parameters, ctx, stack, l) || {};\n      if (++limitCounter > limit) {\n        break;\n      }\n    }\n\n    if (i >= lines.length) {\n      // Type and params are added to the list of items, get rid of them.\n      delete ctx.type;\n      delete ctx.params;\n    }\n\n    if (cb) {\n      if (i < lines.length) {\n        setImmediate(() => {\n          self.parseLines(lines, limit, ctx, stack, i + 1, cb);\n        });\n      } else {\n        setImmediate(() => {\n          cb(null, ctx);\n        });\n      }\n    } else {\n      return ctx;\n    }\n  },\n\n  getLineBreakChar(string) {\n    const indexOfLF = string.indexOf('\\n', 1); // No need to check first-character\n\n    if (indexOfLF === -1) {\n      if (string.includes('\\r')) {\n        return '\\r';\n      }\n\n      return '\\n';\n    }\n\n    if (string[indexOfLF - 1] === '\\r') {\n      return '\\r?\\n';\n    }\n\n    return '\\n';\n  },\n\n  parseICS(string, cb) {\n    const self = this;\n    const lineEndType = self.getLineBreakChar(string);\n    const lines = string.split(lineEndType === '\\n' ? /\\n/ : /\\r?\\n/);\n    let ctx;\n\n    if (cb) {\n      // Asynchronous execution\n      self.parseLines(lines, 2000, cb);\n    } else {\n      // Synchronous execution\n      ctx = self.parseLines(lines, lines.length);\n      return ctx;\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}